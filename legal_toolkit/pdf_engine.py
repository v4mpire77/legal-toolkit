"""
Module: PDF Engine
Description: High-performance PDF manipulation using PyMuPDF (fitz).
             Handles merging, Bates stamping, and TOC generation.
"""

import os
import fitz  # PyMuPDF
from typing import List, Dict

class PDFEngine:
    def __init__(self):
        pass

    def merge_pdfs(self, input_files: List[str], output_path: str, bates_prefix: str = None):
        """
        Merges multiple PDFs into a single document, generates a hyperlinked index,
        and optionally applies Bates stamping.
        """
        temp_doc = fitz.open()
        toc_entries = []
        current_page = 0

        for file_path in input_files:
            if not os.path.exists(file_path) or not file_path.lower().endswith('.pdf'):
                continue
            
            src_doc = fitz.open(file_path)
            page_count = len(src_doc)
            
            # Add to TOC metadata list
            file_name = os.path.basename(file_path)
            # TOC format: [level, title, page_number]
            # page_number will be adjusted after index insertion
            toc_entries.append({"title": file_name, "start_page": current_page + 1})
            
            # Insert pages
            temp_doc.insert_pdf(src_doc)
            current_page += page_count
            src_doc.close()

        # Generate the Index Page(s)
        index_doc = self._generate_index_doc(toc_entries)
        index_page_count = len(index_doc)

        # Create Final Document: [Index] + [Content]
        final_doc = fitz.open()
        final_doc.insert_pdf(index_doc)
        final_doc.insert_pdf(temp_doc)
        
        # Adjust TOC page numbers for the index pages
        final_toc = []
        for entry in toc_entries:
            final_toc.append([1, entry["title"], entry["start_page"] + index_page_count])
        
        # Apply Internal Hyperlinks on the Index Page
        self._apply_index_links(final_doc, toc_entries, index_page_count)

        # Apply Bates Stamping if requested (stamps everything including index)
        if bates_prefix:
            self._apply_bates_stamping(final_doc, bates_prefix)

        # Set PDF TOC (for Sidebar navigation)
        final_doc.set_toc(final_toc)
        
        # Save and Cleanup
        final_doc.save(output_path)
        final_doc.close()
        temp_doc.close()
        index_doc.close()
        return output_path

    def _generate_index_doc(self, toc_entries: List[Dict]) -> fitz.Document:
        """
        Creates a new PDF document containing the Index/Table of Contents.
        """
        doc = fitz.open()
        page = doc.new_page()
        
        # Title
        page.insert_text((50, 50), "INDEX OF DOCUMENTS", fontsize=16, fontname="helv")
        page.insert_text((50, 70), "Generated by Legal Toolkit", fontsize=10, fontname="helv")
        
        # Headers
        page.insert_text((50, 100), "Document Name", fontsize=12, fontname="helv")
        page.insert_text((500, 100), "Page", fontsize=12, fontname="helv")
        
        # Entries
        y_pos = 125
        for entry in toc_entries:
            # Handle page overflow (simplified)
            if y_pos > 750:
                page = doc.new_page()
                y_pos = 50
            
            page.insert_text((50, y_pos), entry["title"], fontsize=11, fontname="helv")
            # We don't know the final absolute page until we know index_page_count
            # but we can placeholder it or calculate it later. 
            # For the text, we'll calculate it in the caller.
            y_pos += 20
            
        return doc

    def _apply_index_links(self, doc: fitz.Document, toc_entries: List[Dict], index_page_count: int):
        """
        Adds clickable rectangles to the index pages.
        """
        # Note: This is a simplified implementation. 
        # In a production environment, we'd accurately track text positions.
        index_page = doc[0]
        y_pos = 125
        
        for entry in toc_entries:
            # Create a link rectangle: Rect(x0, y0, x1, y1)
            # Roughly covers the line height
            link_rect = fitz.Rect(50, y_pos - 12, 550, y_pos + 5)
            
            target_page = entry["start_page"] + index_page_count - 1 # 0-indexed
            
            # Create the link
            index_page.insert_link({
                "kind": fitz.LINK_GOTO,
                "from": link_rect,
                "page": target_page
            })
            
            # Draw the page number text on the index page now that we know the offset
            index_page.insert_text((505, y_pos), str(target_page + 1), fontsize=11, fontname="helv")
            
            y_pos += 20

    def _apply_bates_stamping(self, doc: fitz.Document, prefix: str):
        """
        Applies sequential Bates numbering to the footer of every page.
        """
        for i, page in enumerate(doc):
            rect = page.rect
            p = fitz.Point(rect.width - 120, rect.height - 20)
            bates_text = f"{prefix}-{i+1:06d}"
            
            page.insert_text(
                p,
                bates_text,
                fontsize=10,
                fontname="helv",
                color=(0, 0, 0)
            )

    def generate_smart_bundle(self, source_dir: str, output_name: str, bates_prefix: str = "BUNDLE"):
        """
        Automatically finds all PDFs in a directory and creates a stamped, indexed bundle.
        """
        files = [os.path.join(source_dir, f) for f in os.listdir(source_dir) if f.lower().endswith('.pdf')]
        files.sort()
        
        output_path = os.path.join(source_dir, output_name)
        if not os.path.abspath(output_path).startswith(os.path.abspath(source_dir)):
             raise ValueError("Security Violation")
             
        return self.merge_pdfs(files, output_path, bates_prefix)